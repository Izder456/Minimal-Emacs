<p>In my article about running <a rel="noopener" target="_blank" href="https://www.cambus.net/freebsd-on-the-vortex86dx-cpu/">FreeBSD on the Vortex86DX CPU</a>, I mentioned
using <strong>objdump</strong> to disassemble kernels in order to check whether they were
using CMOV instructions or not.</p>
<p>One thing leading to another, I thought it would be fun to calculate the
<strong>distribution of assembly instructions</strong> in <strong>ELF binaries</strong>. It turns out
it can be done rather easily with a bit of Shell foo.</p>
<p>For the purpose of this article, I used <strong>SQLite</strong> 3.38.5 (2022-05-06) built
with <strong>GCC 12.1.1</strong> on Fedora 36 using the default optimization level (-O2)
as a target binary to test instructions distribution against. It is a
self-contained, full-featured SQL database engine as a single binary, making
it an excellent choice for our experiment.</p>
<pre data-lang="sh" style="background-color:#272822;color:#f8f8f2;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ gcc</span><span style="font-style:italic;color:#fd971f;"> --version
</span><span>gcc (GCC) 12.1.1 20220507 (Red Hat 12.1.1-1)
</span><span>Copyright (C) 2022 Free Software Foundation, Inc.
</span><span>This is free software</span><span style="color:#f92672;">; </span><span>see the source for copying conditions.  There is NO
</span><span>warranty</span><span style="color:#f92672;">; </span><span>not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span></code></pre>
<p>For the record, the example below is using <em>objdump</em> 2.37 from <strong>GNU binutils</strong>
on a Linux system.</p>
<p>The naive solution:</p>
<pre data-lang="sh" style="background-color:#272822;color:#f8f8f2;" class="language-sh "><code class="language-sh" data-lang="sh"><span>objdump</span><span style="font-style:italic;color:#fd971f;"> -dj</span><span> .text</span><span style="font-style:italic;color:#fd971f;"> --no-show-raw-insn --no-addresses</span><span> sqlite3 </span><span style="color:#f92672;">| </span><span>\
</span><span>	grep </span><span style="color:#e6db74;">$&#39;^</span><span style="color:#ae81ff;">\t</span><span style="color:#e6db74;">&#39; </span><span style="color:#f92672;">| </span><span>awk</span><span style="font-style:italic;color:#fd971f;"> -F </span><span style="color:#e6db74;">&#39;\t&#39;</span><span style="font-style:italic;color:#fd971f;"> -F </span><span style="color:#e6db74;">&#39; &#39; &#39;{ print $1 }&#39; </span><span style="color:#f92672;">| </span><span>\
</span><span>	sort </span><span style="color:#f92672;">| </span><span>uniq</span><span style="font-style:italic;color:#fd971f;"> -c </span><span style="color:#f92672;">| </span><span>sort</span><span style="font-style:italic;color:#fd971f;"> -nr
</span></code></pre>
<p>There is a problem with this approach however, it doesn't differentiate
between instructions and prefixes, so for prefixed instructions, we only
account for the prefixes and discard the actual instructions. Given the
choice between adding more Shell hackery and reaching out for a proper
instruction decoder, I opted for the later.</p>
<p>I already knew about <a rel="noopener" target="_blank" href="https://www.capstone-engine.org">Capstone</a> so this is the one I decided to use.
It is widely packaged, supports multiple architectures, and also has
<a rel="noopener" target="_blank" href="https://www.capstone-engine.org/lang_python.html">Python bindings</a> which makes it an extremely convenient option. As a
word of caution, the reader should be aware that if we compare the results
provided by different tools, we will notice divergences.
Distinct disassemblers decode instructions differently, and this is
exacerbated on <strong>x86-64</strong> due to the complexity of the instruction decoder.
Hardware decoders should be considered the only source of truth.</p>
<p>Here is a small Python snippet using Capstone 4.0.2 to print one instruction
per line:</p>
<pre data-lang="python" style="background-color:#272822;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#75715e;">#!/usr/bin/env python3
</span><span style="color:#f92672;">import </span><span>sys
</span><span style="color:#f92672;">from </span><span>capstone </span><span style="color:#f92672;">import </span><span style="color:#ae81ff;">*
</span><span>
</span><span style="color:#f92672;">with </span><span style="color:#66d9ef;">open</span><span>(sys.argv[</span><span style="color:#ae81ff;">1</span><span>],</span><span style="color:#e6db74;">&#39;rb&#39;</span><span>) </span><span style="color:#f92672;">as </span><span>file:
</span><span>    text </span><span style="color:#f92672;">= </span><span>file.read()
</span><span>
</span><span>    md </span><span style="color:#f92672;">= </span><span>Cs(CS_ARCH_X86, CS_MODE_64)
</span><span>    </span><span style="color:#f92672;">for </span><span>insn </span><span style="color:#f92672;">in </span><span>md.disasm(text, </span><span style="color:#ae81ff;">0x0</span><span>):
</span><span>        </span><span style="color:#66d9ef;">print</span><span>(</span><span style="color:#e6db74;">&quot;</span><span style="color:#ae81ff;">%s</span><span style="color:#e6db74;">&quot; </span><span style="color:#f92672;">%</span><span>(insn.mnemonic.split().pop()))
</span></code></pre>
<p>As previously when we used <em>objdump</em>, we are only interested by the <strong>.text
section</strong>, so we need to extract it from the binary using <em>objcopy</em>:</p>
<pre data-lang="sh" style="background-color:#272822;color:#f8f8f2;" class="language-sh "><code class="language-sh" data-lang="sh"><span>objcopy</span><span style="font-style:italic;color:#fd971f;"> --dump-section</span><span> .text=sqlite3.text sqlite3
</span></code></pre>
<p>We can then use the Python program we created to compute our distribution:</p>
<pre data-lang="sh" style="background-color:#272822;color:#f8f8f2;" class="language-sh "><code class="language-sh" data-lang="sh"><span>./insn.py sqlite3.text </span><span style="color:#f92672;">| </span><span>sort </span><span style="color:#f92672;">| </span><span>uniq</span><span style="font-style:italic;color:#fd971f;"> -c </span><span style="color:#f92672;">| </span><span>sort</span><span style="font-style:italic;color:#fd971f;"> -nr
</span></code></pre>
<p>Here are the first 10 lines of results, showing the most used instructions:</p>
<pre data-lang="sh" style="background-color:#272822;color:#f8f8f2;" class="language-sh "><code class="language-sh" data-lang="sh"><span> 106158 mov
</span><span>  19462 test
</span><span>  17918 call
</span><span>  15866 je
</span><span>  15566 cmp
</span><span>  13276 jmp
</span><span>  12720 nop
</span><span>  12072 jne
</span><span>  11629 pop
</span><span>  10873 xor
</span></code></pre>
<p>The full set of results is available for download <a href="/files/asm/data/instructions.csv">here</a> in CSV format.</p>
<p>Here is a visualization of the 50 most used instructions using logarithmic
scale:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="instructions"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('instructions').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['mov', 'test', 'call', 'je', 'cmp', 'jmp', 'nop', 'jne', 'pop', 'xor', 'add', 'lea', 'push', 'movzx', 'sub', 'movsxd', 'ret', 'and', 'jle', 'shl', 'or', 'jg', 'movups', 'movaps', 'movsx', 'pxor', 'ja', 'shr', 'js', 'jbe', 'jae', 'cdqe', 'jb', 'imul', 'jge', 'movq', 'sete', 'movsd', 'jl', 'cmove', 'sar', 'movabs', 'setne', 'movdqu', 'bswap', 'jns', 'movd', 'cmovne', 'not', 'movdqa'],
        datasets: [{
            label: 'Assembly instructions',
            data: [106158, 19462, 17918, 15866, 15566, 13276, 12720, 12072, 11629, 10873, 10015, 9861, 7578, 6176, 4719, 3662, 3322, 2490, 2036, 1721, 1538, 1068, 935, 831, 769, 643, 603, 586, 583, 510, 484, 452, 424, 371, 364, 354, 339, 331, 330, 316, 311, 301, 283, 265, 235, 233, 228, 198, 188, 188],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>While being able to visualize the number of occurrences for every
instruction is valuable, the produced charts are a bit noisy if we want
to include the whole set. We can remedy this by grouping instructions by
categories.</p>
<p>Here is another chart, showing instructions grouped by category:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="categories"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('categories').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['Data Transfer Instructions', 'Control Transfer Instructions', 'Binary Arithmetic Instructions', 'Miscellaneous Instructions', 'Bit and Byte Instructions', 'Logical Instructions', 'Shift and Rotate Instructions', 'SSE Data Transfer Instructions', 'MMX Logical Instructions', 'MMX Data Transfer Instructions', 'SSE2 128-Bit SIMD Integer Instructions', 'SSE2 Data Movement Instructions', 'SSE2 Conversion Instructions', 'SSE2 Packed Arithmetic Instructions', 'String Instructions', 'x87 FPU Data Transfer Instructions', 'SSE2 Compare Instructions', 'MMX Conversion Instructions', 'SSE2 Logical Instructions', 'x87 FPU Basic Arithmetic Instructions', 'MMX Packed Arithmetic Instructions', 'SSE Packed Arithmetic Instructions', 'x87 FPU Comparison Instructions', 'SSE Comparison Instructions', 'SSE2 Shuffle and Unpack Instructions', 'SSE Shuffle and Unpack Instructions', 'x87 FPU Load Constants Instructions', 'x87 FPU Control Instructions', 'SSE 64-Bit SIMD Integer Instructions', 'Control Transfer Terminating Instructions', 'MMX Comparison Instructions', 'SSE Conversion Instructions', 'SSE Logical Instructions', 'System Instructions'],
        datasets: [{
            label: 'Assembly instructions grouped by category',
            data: [138114, 69122, 31092, 22615, 20318, 15089, 2821, 1932, 647, 582, 542, 391, 255, 174, 154, 149, 123, 73, 26, 26, 22, 22, 22, 19, 19, 11, 7, 6, 5, 4, 1, 1, 1, 1],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>The dataset with instructions grouped by categories is available for download <a href="/files/asm/data/categories.csv">here</a> in CSV format.</p>
<p>So what can we take away from these numbers? MOV is by far the most used
instruction, and grouping by category also shows that the top contenders
are data transfer instructions. Not surprising, and this is why data
locality is so important for performance.</p>
<p>We can also notice that by default, GCC doesn't take advantage of modern
CPUs features like SSE3, SSE4, and AVX instructions.</p>
<p>GCC 11 and Clang 12 introduced support for <strong>x86-64 micro-architecture
levels</strong> as documented <a rel="noopener" target="_blank" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html">here</a> and <a rel="noopener" target="_blank" href="https://clang.llvm.org/docs/UsersManual.html#x86">here</a> respectively for each compiler.
This was first <a rel="noopener" target="_blank" href="https://sourceware.org/pipermail/libc-alpha/2020-July/116135.html">discussed in 2020</a> and is now part of the <a rel="noopener" target="_blank" href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/commit/77566eb03bc6a326811cb7e9">x86-64 psABI</a>.
Each micro-architecture level can be enabled by setting the march flag
to one of the following values:</p>
<ul>
<li><strong>x86-64</strong>: CMOV, CMPXCHG8B, FPU, FXSR, MMX, FXSR, SCE, SSE, SSE2</li>
<li><strong>x86-64-v2</strong>: (close to Nehalem) CMPXCHG16B, LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3</li>
<li><strong>x86-64-v3</strong>: (close to Haswell) AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, XSAVE</li>
<li><strong>x86-64-v4</strong>: AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL</li>
</ul>
<p>When building with <strong>x86-64-v2</strong>, here are the 50 most used instructions:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="instructions-x86-64-v2"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('instructions-x86-64-v2').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['mov', 'test', 'call', 'je', 'cmp', 'jmp', 'nop', 'jne', 'pop', 'xor', 'add', 'lea', 'push', 'movzx', 'sub', 'movsxd', 'ret', 'and', 'jle', 'shl', 'or', 'jg', 'movups', 'movaps', 'movsx', 'pxor', 'ja', 'shr', 'js', 'jbe', 'jae', 'cdqe', 'jb', 'imul', 'jge', 'sete', 'movq', 'jl', 'movsd', 'cmove', 'sar', 'movabs', 'setne', 'movdqu', 'jns', 'movd', 'bswap', 'movdqa', 'cmovne', 'not'],
        datasets: [{
            label: 'Assembly instructions',
            data: [106134, 19454, 17918, 15866, 15551, 13278, 12732, 12071, 11621, 10862, 10016, 9855, 7573, 6164, 4718, 3656, 3322, 2490, 2037, 1722, 1536, 1068, 938, 837, 769, 651, 602, 586, 583, 506, 484, 448, 424, 370, 363, 339, 333, 330, 322, 316, 311, 301, 283, 265, 233, 227, 217, 213, 198, 188],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>And here are instructions grouped by category:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="categories-x86-64-v2"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('categories-x86-64-v2').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['Data Transfer Instructions', 'Control Transfer Instructions', 'Binary Arithmetic Instructions', 'Miscellaneous Instructions', 'Bit and Byte Instructions', 'Logical Instructions', 'Shift and Rotate Instructions', 'SSE Data Transfer Instructions', 'MMX Logical Instructions', 'MMX Data Transfer Instructions', 'SSE2 128-Bit SIMD Integer Instructions', 'SSE2 Data Movement Instructions', 'SSE2 Conversion Instructions', 'Insertion and Extractions from XMM Registers', 'SSE2 Packed Arithmetic Instructions', 'String Instructions', 'x87 FPU Data Transfer Instructions', 'SSE2 Compare Instructions', 'MMX Packed Arithmetic Instructions', 'x87 FPU Basic Arithmetic Instructions', 'Packed Integer MIN/MAX Instructions', 'SSE Packed Arithmetic Instructions', 'x87 FPU Comparison Instructions', 'SSE Comparison Instructions', 'SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions', 'Packed Shuffle Bytes', 'SSE2 Shuffle and Unpack Instructions', 'SSE Shuffle and Unpack Instructions', 'Packed Blending Instructions', 'x87 FPU Load Constants Instructions', 'SSE2 Logical Instructions', 'Packed Integer Format Conversions', 'SSE 64-Bit SIMD Integer Instructions', 'Control Transfer Terminating Instructions', 'Packed Align Right', 'Dword Packing With Unsigned Saturation', 'Floating-Point Round Instructions with Selectable Rounding Mode', 'SSE3 x87-FP Integer Conversion Instruction', 'Dword Multiply Instructions', 'MMX Comparison Instructions', 'MMX Conversion Instructions', 'MMX Shift and Rotate Instructions', 'Packed Absolute Values', 'SSE Conversion Instructions', 'SSE Logical Instructions', 'SSE3 SIMD Floating-Point Packed ADD/SUB Instructions', 'System Instructions'],
        datasets: [{
            label: 'Assembly instructions grouped by category',
            data: [138014, 69118, 31075, 22621, 20310, 15076, 2822, 1837, 661, 560, 521, 386, 251, 201, 171, 154, 147, 120, 30, 26, 23, 22, 22, 19, 15, 14, 14, 11, 8, 7, 6, 5, 5, 4, 4, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>We can notice that the <strong>x86-64-v2</strong> level takes advantage of <strong>SSE3</strong>
instructions.</p>
<p>The following extra instructions are used:</p>
<p>ADDSUBPD, BLENDVPD, CMPLESD, FISTTP, MOVDDUP, PABSD, PACKUSDW, PADDQ,
PALIGNR, PBLENDW, PEXTRD, PEXTRQ, PINSRD, PINSRQ, PMAXSD, PMAXUD, PMINSD,
PMINUD, PMOVSXDQ, PMULLD, POR, PSHUFB, PSLLD, PSRLDQ, and ROUNDSD.</p>
<p>When building with <strong>x86-64-v3</strong>, here are the 50 most used instructions:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="instructions-x86-64-v3"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('instructions-x86-64-v3').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['mov', 'test', 'call', 'je', 'cmp', 'jmp', 'nop', 'jne', 'pop', 'xor', 'add', 'lea', 'push', 'movzx', 'sub', 'movsxd', 'ret', 'and', 'jle', 'shl', 'or', 'vmovdqu', 'jg', 'movsx', 'vmovdqa', 'ja', 'js', 'shr', 'jbe', 'jae', 'cdqe', 'jb', 'vpxor', 'imul', 'vmovsd', 'jge', 'vmovq', 'sete', 'vmovaps', 'jl', 'cmove', 'sar', 'movabs', 'setne', 'movbe', 'vmovd', 'jns', 'cmovne', 'andn', 'vpinsrq'],
        datasets: [{
            label: 'Assembly instructions',
            data: [105641, 19442, 17920, 15862, 15535, 13269, 12740, 12073, 11641, 10863, 9996, 9846, 7588, 6091, 4717, 3658, 3321, 2360, 2034, 1583, 1536, 1193, 1076, 771, 666, 603, 583, 563, 506, 484, 448, 425, 395, 367, 365, 363, 339, 339, 334, 328, 316, 302, 295, 283, 275, 236, 233, 199, 134, 130],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>And here are instructions grouped by category:</p>
<div style="width: 100%;height: 768px;margin: 0 auto">
    <canvas id="categories-x86-64-v3"></canvas>
</div>
<script src="/scripts/chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('categories-x86-64-v3').getContext('2d');
    var options = 
{
    type: 'bar',
    data: {
        labels: ['Data Transfer Instructions', 'Control Transfer Instructions', 'Binary Arithmetic Instructions', 'Miscellaneous Instructions', 'Bit and Byte Instructions', 'Logical Instructions', 'AVX Instructions', 'Shift and Rotate Instructions', 'BMI2 Instructions', 'String Instructions', 'BMI1 Instructions', 'x87 FPU Data Transfer Instructions', 'x87 FPU Basic Arithmetic Instructions', 'AVX2 Instructions', 'x87 FPU Comparison Instructions', 'FMA Instructions', 'x87 FPU Load Constants Instructions', 'Control Transfer Terminating Instructions', 'SSE3 x87-FP Integer Conversion Instruction', 'SSE2 Data Movement Instructions', 'System Instructions'],
        datasets: [{
            label: 'Assembly instructions grouped by category',
            data: [137288, 69114, 31035, 22895, 20295, 14832, 4757, 2450, 270, 154, 151, 147, 26, 24, 22, 19, 7, 4, 2, 1, 1],
            backgroundColor: ['#4e79a7', '#a0cbe8', '#f28e2b', '#ffbe7d', '#59a14f', '#8cd17d', '#b6992d', '#f1ce63', '#499894', '#86bcb6', '#e15759', '#ff9d9a', '#79706e', '#bab0ac', '#d37295', '#fabfd2', '#b07aa1', '#d4a6c8', '#9d7660', '#d7b5a6'],
        }]
    },
    options: {
        maintainAspectRatio: false,
        scales: {
            x: {
               ticks: {
                   autoSkip: false
               }
            },
            y: {
                display: true,
                type: 'logarithmic'
            }
        }
    }
};
    new Chart(ctx, options);
</script>
<p>The <strong>x86-64-v3</strong> level takes advantage of <strong>AVX</strong> and <strong>AVX2</strong> instructions,
as well as <strong>BMI1</strong>, <strong>BMI2</strong>, and <strong>FMA</strong> instructions.</p>
<p>The following extra instructions are used:</p>
<p>ANDN, BLSR, LEAVE, LZCNT, MOVBE, RORX, SARX, SHLX, SHRX, VADDPD, VADDSD,
VADDSS, VADDSUBPD, VBLENDVPD, VCMPLESD, VCMPLTSD, VCMPNLTSD, VCOMISD,
VCOMISS, VCVTDQ2PD, VCVTPD2PS, VCVTPS2PD, VCVTSD2SS, VCVTSI2SD, VCVTSI2SS,
VCVTSS2SD, VCVTTSD2SI, VDIVSD, VDIVSS, VEXTRACTI128, VFMADD132PD, VFMADD132SD,
VFMADD213SD, VFMADD231SD, VFMSUB132SD, VFNMADD231SD, VINSERTF128, VINSERTI128,
VMAXSS, VMINSD, VMINSS, VMOVAPD, VMOVAPS, VMOVD, VMOVDDUP, VMOVDQA, VMOVDQU,
VMOVLHPS, VMOVLPS, VMOVQ, VMOVSD, VMOVSS, VMOVUPD, VMOVUPS, VMULPD, VMULSD,
VMULSS, VPABSD, VPACKUSDW, VPACKUSWB, VPADDB, VPADDD, VPADDQ, VPADDW,
VPALIGNR, VPAND, VPBLENDW, VPBROADCASTB, VPBROADCASTD, VPBROADCASTQ,
VPBROADCASTW, VPCMPEQD, VPERMQ, VPEXTRD, VPEXTRQ, VPEXTRW, VPINSRD, VPINSRQ,
VPMAXSD, VPMAXUD, VPMINSD, VPMINUD, VPMOVSXDQ, VPMULLD, VPOR, VPSHUFB,
VPSHUFD, VPSHUFLW, VPSLLD, VPSUBD, VPUNPCKLQDQ, VPXOR, VROUNDSD, VSHUFPD,
VSUBSD, VSUBSS, VUCOMISD, VUCOMISS, VUNPCKLPD, VUNPCKLPS, VXORPD, VXORPS,
and VZEROUPPER.</p>
<p>The full counts of used instructions are available for download in CSV format
for the <a href="/files/asm/data/instructions-v2.csv">x86-64-v2</a> and <a href="/files/asm/data/instructions-v3.csv">x86-64-v3</a> levels.</p>
<p>I'm leaving out the <strong>x86-64-v4</strong> level for now, as I was getting weird
instructions counts compared to the others binaries, so it seems something
got wrong at some point. I might revisit this in the future.</p>
<p><strong>EDIT:</strong> Harold kindly <a rel="noopener" target="_blank" href="https://twitter.com/HaroldAptroot/status/1542165356701257730">pointed out</a> on Twitter that while it seems
MMX instructions are used a lot, it's probably mainly/only the SSE2 versions
that are used instead.</p>
