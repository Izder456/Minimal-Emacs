<p>As mentioned in my previous post about <a rel="noopener" target="_blank" href="https://www.cambus.net/playing-with-djgpp-and-gcc-10-on-dos/">playing with DJGPP and GCC 10 on DOS</a>,
I have been redoing my small character and color cycling effect in text
mode. The original version in JavaScript can be seen <a rel="noopener" target="_blank" href="https://www.cambus.net/character-and-color-cycling-effect-in-javascript/">here</a>.</p>
<p><img src="/content/2021/05/cycling-effect.png" alt="Cycling effect" /></p>
<p>To understand why we can't access video memory directly and need to use the
DPMI service to create a selector to access the required real-mode segment
address, please refer to <a rel="noopener" target="_blank" href="https://www.delorie.com/djgpp/v2faq/faq18_4.html">section 18.4 of the DJGPP FAQ</a>.</p>
<p>The effect can be downloaded <a href="/content/2021/05/cycling.exe">here</a>. Sadly, the resulting binary is quite
large (104K stripped!), and it requires <a rel="noopener" target="_blank" href="https://sandmann.dotster.com/cwsdpmi/">CWSDPMI</a> to run.</p>
<p>Here is the code:</p>
<pre data-lang="c" style="background-color:#272822;color:#f8f8f2;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#f92672;">#include </span><span style="color:#e6db74;">&lt;conio.h&gt;
</span><span style="color:#f92672;">#include </span><span style="color:#e6db74;">&lt;dpmi.h&gt;
</span><span style="color:#f92672;">#include </span><span style="color:#e6db74;">&lt;go32.h&gt;
</span><span style="color:#f92672;">#include </span><span style="color:#e6db74;">&lt;pc.h&gt;
</span><span>
</span><span style="font-style:italic;color:#66d9ef;">void
</span><span style="color:#a6e22e;">wait_vbl</span><span>()
</span><span>{
</span><span>	</span><span style="color:#f92672;">while</span><span>(inp(</span><span style="color:#ae81ff;">0x3da</span><span>) </span><span style="color:#f92672;">&amp; </span><span style="color:#ae81ff;">0x08</span><span>);
</span><span>	</span><span style="color:#f92672;">while</span><span>(</span><span style="color:#f92672;">!</span><span>(inp(</span><span style="color:#ae81ff;">0x3da</span><span>) </span><span style="color:#f92672;">&amp; </span><span style="color:#ae81ff;">0x08</span><span>));
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#66d9ef;">int
</span><span style="color:#a6e22e;">main</span><span>()
</span><span>{
</span><span>	</span><span style="font-style:italic;color:#66d9ef;">short</span><span> video </span><span style="color:#f92672;">= </span><span>__dpmi_segment_to_descriptor(</span><span style="color:#ae81ff;">0xb800</span><span>);
</span><span>	</span><span style="font-style:italic;color:#66d9ef;">unsigned char</span><span> buffer[</span><span style="color:#ae81ff;">4000</span><span>];
</span><span>
</span><span>	</span><span style="font-style:italic;color:#66d9ef;">int</span><span> character </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0</span><span>, color </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0</span><span>;
</span><span>
</span><span>	</span><span style="color:#75715e;">/* Define character and color arrays */
</span><span>	</span><span style="font-style:italic;color:#66d9ef;">char</span><span> characters[] </span><span style="color:#f92672;">= </span><span>{ </span><span style="color:#ae81ff;">0x5c</span><span>, </span><span style="color:#ae81ff;">0x7c</span><span>, </span><span style="color:#ae81ff;">0x2f</span><span>, </span><span style="color:#ae81ff;">0x2d </span><span>};
</span><span>	</span><span style="font-style:italic;color:#66d9ef;">char</span><span> colors[] </span><span style="color:#f92672;">= </span><span>{ </span><span style="color:#ae81ff;">0xf</span><span>, </span><span style="color:#ae81ff;">0xb</span><span>, </span><span style="color:#ae81ff;">0x9</span><span>, </span><span style="color:#ae81ff;">0x1</span><span>, </span><span style="color:#ae81ff;">0x9</span><span>, </span><span style="color:#ae81ff;">0xb</span><span>, </span><span style="color:#ae81ff;">0xf </span><span>};
</span><span>
</span><span>	</span><span style="color:#f92672;">while </span><span>(</span><span style="color:#f92672;">!</span><span>kbhit()) {
</span><span>		</span><span style="color:#f92672;">for </span><span>(</span><span style="font-style:italic;color:#66d9ef;">size_t</span><span> offset </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">0</span><span>; offset </span><span style="color:#f92672;">&lt; </span><span style="color:#ae81ff;">4000</span><span>; offset </span><span style="color:#f92672;">+= </span><span style="color:#ae81ff;">2</span><span>) {
</span><span>			</span><span style="color:#75715e;">/* Write character and color data */
</span><span>			buffer[offset] </span><span style="color:#f92672;">=</span><span> characters[character];
</span><span>			buffer[offset </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1</span><span>] </span><span style="color:#f92672;">=</span><span> colors[color];
</span><span>
</span><span>			</span><span style="color:#75715e;">/* Increment the color index */
</span><span>			color </span><span style="color:#f92672;">=</span><span> color </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">&lt; sizeof</span><span>(colors) </span><span style="color:#f92672;">?</span><span> color </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">: </span><span style="color:#ae81ff;">0</span><span>;
</span><span>		}
</span><span>
</span><span>		</span><span style="color:#75715e;">/* Increment the character index */
</span><span>		character </span><span style="color:#f92672;">=</span><span> character </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">&lt; sizeof</span><span>(characters) </span><span style="color:#f92672;">?
</span><span>		    character </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">: </span><span style="color:#ae81ff;">0</span><span>;
</span><span>
</span><span>		</span><span style="color:#75715e;">/* Copy the buffer into text mode video memory */
</span><span>		movedata(_my_ds(), (</span><span style="font-style:italic;color:#66d9ef;">unsigned</span><span>)buffer, video, </span><span style="color:#ae81ff;">0</span><span>, </span><span style="color:#ae81ff;">4000</span><span>);
</span><span>
</span><span>		</span><span style="color:#75715e;">/* Wait for VBL */
</span><span>		wait_vbl();
</span><span>		wait_vbl();
</span><span>		wait_vbl();
</span><span>		wait_vbl();
</span><span>		wait_vbl();
</span><span>	}
</span><span>}
</span></code></pre>
